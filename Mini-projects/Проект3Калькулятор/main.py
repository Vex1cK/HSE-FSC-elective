# -*- coding: utf-8 -*-
# Почему-то были технические шоколадки с кодировкой, поэтому я поставилт тут utf-8

numbersAndSigns = {
    # Это основной словарь программы. Именно с помощью него строка "два" превратится в строку "2" и т.д.
    "ноль": "0",
    'один': '1',
    'два': '2',
    'три': "3",
    'четыре': "4",
    'пять' : '5',
    'шесть': '6',
    'семь': '7',
    'восемь': '8',
    'девять': '9',
    "десять": "10",
    "одиннадцать": "11",
    "двенадцать": "12",
    "тринадцать": "13",
    "четырнадцать": "14",
    "пятнадцать": "15",
    "шестнадцать": "16",
    "семнадцать": "17",
    "восемнадцать": "18",
    "девятнадцать": "19",
    "двадцать": "20",
    "тридцать": "30",
    "сорок": "40",
    "пятьдесят": "50",
    "шестьдесят": "60",
    "семьдесят": "70",
    "восемьдесят": "80",
    "девяносто": "90",
    "сто": "100",
    "двести": "200",
    "триста": "300",
    "четыреста": "400",
    "пятьсот": "500",
    "шестьсот": "600",
    "семьсот": "700",
    "восемьсот": "800",
    "девятьсот": "900",
    "тысяча": "1000",
    "тысячи": "1000",
    "тысяч": "1000",
    "степени": "**",
    "минус": "-",
    "вычесть": "-",
    'плюс': '+',
    'прибавить': '+',
    'умножить': '*',
    'делить': '/',
    "открывается": '(',
    'закрывается': ')',
}

skip = ['на', 'в', 'скобка', 'скобочка']  # строки которые будут игнорироваться алгоритмом
signs = ["степени", "минус", 'плюс', 'умножить', 'делить', "открывается", 'закрывается']  # строки обозначающие знаки операций или скобки

def printManual():
    # Просто печатаем инструкцию
    print(""" Инструкция к калькулятору:
 1) Ознакомьтесь к ограничениями на вводимые цифры и знаки,
 описанными в файле 'ограничения.txt', а также в 'ТЗ.docx'.
 2) Пока калькулятор активен, вы можете вводить команды или математические выражения:
 2.1) Команды:
      -o -> выход из программы
      -m -> вывод инструкции на экран
 2.2) Ограничения на вводимые математические выражения также описано в файле 'ТЗ.docx'.
      Пример математического выражения:
      Ввод: скобка открывается три плюс один скобка закрывается делить на два
 После ввода математического выражения программа выведет ответ, после чего снова попросит от вас ввод
 Конце инструкции""")

def fromStringToValues(strr: list):
    # Эта функция получает на вход список вида ['два', 'плюс', 'три'] и возвращает строку вида '2+3'
    # Подробнее алгоритм опишу в видео-презентации, здесь кратко опишу что есть что:

    # Я разбиваю строку на числа ("два", "пять тысяч сто три" и т.д.) и на знаки ("плюс", "в степени" и т.д.)
    values = []  # Тут хранятся числа
    signsAndInds = {}  # А тут знаки и их индексы в изначальном массиве strr
    for i in range(len(strr)):  # Пробегаемся по всем индексам в массивчике
        j = strr[i]
        if j in signs or j in skip:  # Если это знак или то, что мы пропускаем - добавляем в словарик
            signsAndInds[i] = j
            continue
    
    # Знаки отделили, теперь числа:
    indsOfSigns = list(signsAndInds) # Берём индексы (они же ключи словаря) знаков
    values.append(strr[:indsOfSigns[0]]) # Берём всё что стояло до первого знака в изначальном запросе (в том числе может быть ничего)
    for i in range(len(indsOfSigns) - 1):
        ind1, ind2 = indsOfSigns[i], indsOfSigns[i+1]
        values.append(strr[ind1+1:ind2])  # Берём все слова между двумя знаками - это гарантированно числа (точнее одно число записанное в несколько слов)
    values.append(strr[indsOfSigns[-1] + 1:]) # Берём всё что стояло после последнего знака в изначальном запросе (в том числе может быть ничего)

    intValues = []  # Список для чисел вида "2543"

    for val in values:  # val -> массив вида ["двести", "тридцать", "четыре"]
        value = 0  # Сумма (она же число)
        ok = False  # Флажок обозначающий что мы что-то удаляли из val
        if any(("тысяч" in val, "тысяча" in val, "тысячи" in val)):
            ok = True  # Собственно удаляю я только если есть тысячи в числе
            if 'тысяча' in val:
                value += 1000
                val = val[1:]  # Вот и удаление
            else:
                value += int(numbersAndSigns[val[0]]) * 1000
                val = val[2:]  # И вот удаление ---->----------->---------------->------------------|
        for k in val:  #                                                                            |
            value += int(numbersAndSigns[k])  #  накапливаем сумму                                  |
        intValues.append(str(value)) if val or ok else ""  # А вот где этот флажок используется <-<-|
    
    answer = ["" for _ in range(len(strr))]  # Это итоговый массив (превратится в строку в последний момент)

    for k in list(signsAndInds):  # Проходмся по всем тем знакам что мы получили
        if signsAndInds[k] in skip:  # Если он в скип, то добавляем его как слово, не как знак "+" или "-"
            answer[k] = signsAndInds[k]
            continue 
        answer[k] = numbersAndSigns[signsAndInds[k]]  # В ином случае - это знак, и его мы уже добавляем.. как знак.

    i = 0
    while i < len(answer) - 1:  # этот цикл уберёт повторяющиеся пустые места между знаками.
        # Т.е. в итоге между каждым знаком либо не будет пустого места (т.к. небыло изначально) либо будет только одно место - под одно число
        if answer[i] == '' and answer[i + 1] == '':
            del answer[i]
            continue
        i += 1

    k = 0  # Это индекс чиселка которое мы берём из intValues
    for i in range(len(answer)):
        if answer[i] == '':  # Собственно теперь на эти пустые места мы и ставим те чиселки
            answer[i] = intValues[k]
            k += 1
        if k == len(intValues):
            break  # Если чиселки закончились - выходим из цикла (по идее это сработает только на последней итерации, но не важно)

    k = 0   # У нас там оставались слова из списка skip в списке answer. Убираем их
    while k < len(answer):
        if answer[k] in skip:
            del answer[k]
            continue
        k += 1
    
    return "".join(answer)  # После чего возвращаем итоговую строку

def main():
    # В начале общаемся с пользователем и печатаем инструкцию если оан ему нужна
    print("Привет! Ты попал в калькулятор.\n Нужна ли вам инструкция по пользованию данным приложением?")
    answr = input("Введите да или нет в любом регистре: ").lower()
    while answr not in ['да', 'нет']:
        print("Некорректный ввод! Попробуйте еще раз")
        answr = input("Введите да или нет в любом регистре: ").lower()
    if answr == "да":
        printManual()
    
    while True:  # Основной цикл калькулятора. Здесь происходит общение с пользователем и получение от него запросов
        com = input("Ввод (команда или мат. выражение): ").lower().split()  # Получаем команду\пример
        if com[0][0] == '-':  # Если первый символ - это команда
            if com[0] == '-o':
                print("Выход...")
                exit()  # Если это команда на выход - выходим
            elif com[0] == '-m':
                printManual()  # Или же выводим инструкцию на экран
                continue
            else:
                print("Неверная команда! Попробуйте еще раз")
                continue  # Сообщаем что такой команды нет
        else:
            com = fromStringToValues(com)  # В ином случае - это не команда, а значит это пример. 
            # Отправляем его на обработку. Из строки "два плюс три" получится "2+3"
            print(f"Ответ: {eval(com)}")  # Ну а такие строки как "2+3" уже можно "пихать" в eval() или exec()
            # Именно с помощью одной из таких команд производятся все математические вычисления (ни бейте =)))))) )

if __name__ == '__main__':  # Правило хорошего тона
    # Запускаем main()
    main() 